# Java_Study

## 作者：冰红茶  
## 参考书籍：《Java编程思想》第四版

------    


  大数据的基础是Java和Linux，以后尽管进不了大数据的领域，也希望能借助此基础进入后端领域^_ ^
     
## 目录
## [一、简介](#1)
### [1.1 对象导论](#1.1)
## [二、基础语法](#2)
### [2.1 操作符](#2.1)
### [2.2 流程控制](#2.2)
## [三、初始化与清理](#3)
### [3.1 初始化](#3.1)
### [3.2 清理](#3.2)
## [四、访问权限与控制](#4)
### [4.1 包：库单元](#4.1)
### [4.2 包访问权限](#4.2)
### [4.3 接口和实现](#4.3)
## [五、复用类](#5)
### [5.1 介绍](#5.1)
## [六、多态](#6)
### [5.1 介绍](#6.1)
        
------      
        
<h2 id='1'>一、简介</h2>
<h3 id='1.1'>1.1 对象导论</h3>  
        
#### 1) 总体思路
> - 模版
        

------      
        
<h2 id='2'>二、基础语法</h2>
<h3 id='2.1'>2.1 操作符</h3>  
        
#### 1) 总体思路
> - 模版
        
<h3 id='2.2'>2.2 流程控制</h3>  
        
#### 1) 总体思路
> - 模版
                
        
------      
        
<h2 id='3'>三、初始化与清理</h2>
<h3 id='3.1'>3.1 初始化</h3>  
        
#### 1) 总体思路
> - 模版
        
<h3 id='3.2'>3.2 清理</h3>  
        
#### 1) 总体思路
> - 模版
        
        
------      
        
<h2 id='4'>四、访问权限与控制</h2>
<h3 id='4.1'>4.1 包：库单元</h3>  
        
#### 1) 介绍
> - 包内包含有一组类，在单一的名字空间之下被组织在一起
> - 比如：全名是java.util.ArrayList
> - 使用的时候利用import关键字
                
                import java.util.ArrayList;
                import java.util.*
> - 一个Java源文件通常被称为是编译单元，带后缀名.java。内部有且仅被允许有一个public类，否则编译器不会接受。在编译单元之中还有额外的类的话，那么在包之外的世界是无法看见这些雷达额。因为他们不是public类，而且他们只要用来为主public类提供支持。
> - package名称的第一部分是类的创建者的反顺序Internet域名

#### 2) 代码组织
> - java可运行程序是一组可以打包并压缩为一个Java文档文件(JAR，使用Java的jar文档生成器)的.class文件。Java解释器负责这些文件的查找
> - 解释器运行过程：
>> - 找出环境变量CLASSPATH，通过CLASSPATH查找.class文件的根目录，
>> - 从根目录开始，解释器获取包的名称并将每个句点替换成斜杆或者反斜杠(这个取决于系统)，以从CLASSPATH根中产生一个路径名称
> - 得到的路径会与CLASSPATH中的各个不同的项相连接，解释器就在这些目录中查找与你所要创建的类的名称相关的.class文件。
        
<h3 id='4.2'>4.2 包访问权限</h3>  
        
#### 1) 介绍
> - 包访问权：默认没有修饰关键词，可以访问包内的类，但是对包外则为private
> - public：则包内外都能访问
> - protected： 继承的类也能访问，但是包外非继承的类则不能访问
> - private：类私有
        
<h3 id='4.3'>4.3 接口和实现</h3>  
        
#### 1) 介绍
> - 具体实现的隐藏：访问权限的控制
> - 封装：把数据和方法包装紧类中，以及具体实现的隐藏，其结果是一个同时带有特征和行为的数据类型。
> - 封装的原因：
>> - 一方面是设定客户端程序员可以使用和不可以使用的界限
>> - 另一方面是将接口和具体实现进行分离，客户端程序员除了可以想接口发送消息之外什么都不可以做，避免破坏客户端代码
#### 2) 一般做法
> - 将public成员至于开头，后面跟着protected、包访问权和private成员
        
<h3 id='4.4'>4.4 类的访问权限</h3>  
        
#### 1) 限制规则
> - 每一个编译单元都只能有一个public类，作为单一的公共接口，如果一个编译单元内有一个或者多个public类，编译器就会给出出错消息
> - 类的公共接口的名称必须跟该编译单元的文件名相匹配，包括大小写，如果不匹配也会报错；
> - 虽然不常用，但是编译单元内完全不带public也是可能的，可以随意对文件命名
        
        
------      
        
<h2 id='5'>五、复用类</h2>
<h3 id='5.1'>5.1 介绍</h3>  
        
#### 1) 四种方法
> - 组合，由现有类的对象所组成
> - 继承 
>> - 需要在构造器中调用基类构造器来初始化基类
>> - 构建过程是从基类“向外”扩散的，所有基类在导出类构造器可以访问它之前就已经完成了初始化。
>> - 编译器会为你合成一个默认的无参构造器，并自动调用
>> - 但是如果你要初始化有参的构造器，则必须借助关键字super.
> - 代理 这个用得比较少，并没有使用extends关键字，而是直接在类中实现继承类，然后继承实例的某些方法
> - 结合使用组合和继承
        
#### 2) 确保正确的清理
> -                                              析构函数是C++中的概念，指的是对象被销毁时自动被调用的函数。
#### 3) 向上转型
> - 由导出类转换为基类，在UML图上显示的是向上移动。
> - 特点：从一个较为专用的类型向通用的类型转换，所以总是安全的
> - 唯一可能发生的事情是丢失方法
> - 如果一个方法是private，他就不是接口，导出类无法覆盖该方法。即便你在导出类以相同的名称不同的修饰关键字（protected or public or 包访问权限）
#### 4) final关键字
> - 通常指“这是无法改变的”
> - 适用范围：数据、方法和类
> - 数据：一个永不改变的编译时常量，或者是运行时被初始化的值，而你不希望它被改变。所以这类常量必须是基本数据类型，而且在定义的时候，必须对其进行赋值
> - 一个既是static又是final的域只占据一段不能改变的存储空间
> - 类或者数组：final使对象引用恒定不变，一旦引用被用于初始化指向一个对象或者数组，就无法再把它改为指向另一个对象。然而，对象本身却是可以被修改的。
> - 方法：好处有两个
>> - 第一把方法锁定，以防止任何继承类修改它的含义，这是处于设计的考虑，保持不变且不会被覆盖；
>> - 第二个原因是效率，但是这种能提高效率的观点是早期提出的。当编译器发现一个final方法的时候，它会进行非常谨慎的判断。跳过执行方法调用机制（将参数压入栈，跳至方法代码处执行，然后跳回并清理栈中的参数，处理返回值）而采用插入程序代码的方式，即内嵌调用，以方法体中实际代码的副本替代方法调用，以消除方法调用的开销。但是如果你的方法很大，程序代码就会膨胀，因而有可能看不到内嵌带来的任何性能的提高。
> - 空白final：即被声明为final但是又未给定初值的域。这样的好处是可以适应不同的对象，而又保持其恒定不变的特性。
> - final和private关键字的比较：类中所有的private都隐晦地指定为final，这是因为在类外无法覆盖它，对private方法添加final修饰词，并不能给该方法增加任何额外的意义；
#### 5) 初始化及类的加载
> - 传统的语言中的顺序
>> - 程序作为启动过程一部分立刻被加载；
>> - 初始化，需要注意，如果某个static期望另一个static在被初始化之前就能有效地使用它，那么就会出现问题
>> - 程序运行
> - Java中就不会存在上述初始化的问题，因为Java中所有的事物都是对象，每个类的编译代码都存在与他自己的独立文件中，该文件只在需要使用程序代码时才会被加载，即加载发生于创建类的而第一个对象之时。“类的代码在初次使用时才加载”。初次使用之处也是static初始化发生之处。这就有效保证了类之间的依赖问题。
        
        
------      
        
<h2 id='6'>六、多态</h2>
<h3 id='6.1'>4.1 介绍</h3>  
        
#### 1) 四种方法
> - 