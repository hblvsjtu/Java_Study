# Java_Study

## 作者：冰红茶  
## 参考书籍：《Java编程思想》第四版

------    


  大数据的基础是Java和Linux，以后尽管进不了大数据的领域，也希望能借助此基础进入后端领域^_ ^
     
## 目录
## [一、简介](#1)
### [1.1 对象导论](#1.1)
## [二、基础语法](#2)
### [2.1 操作符](#2.1)
### [2.2 流程控制](#2.2)
## [三、初始化与清理](#3)
### [3.1 初始化](#3.1)
### [3.2 清理](#3.2)
## [四、访问权限与控制](#4)
### [4.1 包：库单元](#4.1)
### [4.2 包访问权限](#4.2)
### [4.3 接口和实现](#4.3)
## [五、复用类](#5)
### [5.1 介绍](#5.1)
## [六、多态](#6)
### [6.1 介绍](#6.1)
### [6.2 构造器和多态](#6.2)
### [6.3 用继承进行设计](#6.3)
## [七、接口](#7)
### [7.1 介绍](#7.1)
### [7.2 构造器和多态](#7.2)
### [7.3 用继承进行设计](#7.3)
        
------      
        
<h2 id='1'>一、简介</h2>
<h3 id='1.1'>1.1 对象导论</h3>  
        
#### 1) 总体思路
> - 模版
        

------      
        
<h2 id='2'>二、基础语法</h2>
<h3 id='2.1'>2.1 操作符</h3>  
        
#### 1) 总体思路
> - 模版
        
<h3 id='2.2'>2.2 流程控制</h3>  
        
#### 1) 总体思路
> - 模版
                
        
------      
        
<h2 id='3'>三、初始化与清理</h2>
<h3 id='3.1'>3.1 初始化</h3>  
        
#### 1) 总体思路
> - 模版
        
<h3 id='3.2'>3.2 清理</h3>  
        
#### 1) 总体思路
> - 模版
        
        
------      
        
<h2 id='4'>四、访问权限与控制</h2>
<h3 id='4.1'>4.1 包：库单元</h3>  
        
#### 1) 介绍
> - 包内包含有一组类，在单一的名字空间之下被组织在一起
> - 比如：全名是java.util.ArrayList
> - 使用的时候利用import关键字
                
                import java.util.ArrayList;
                import java.util.*
> - 一个Java源文件通常被称为是编译单元，带后缀名.java。内部有且仅被允许有一个public类，否则编译器不会接受。在编译单元之中还有额外的类的话，那么在包之外的世界是无法看见这些雷达额。因为他们不是public类，而且他们只要用来为主public类提供支持。
> - package名称的第一部分是类的创建者的反顺序Internet域名

#### 2) 代码组织
> - java可运行程序是一组可以打包并压缩为一个Java文档文件(JAR，使用Java的jar文档生成器)的.class文件。Java解释器负责这些文件的查找
> - 解释器运行过程：
>> - 找出环境变量CLASSPATH，通过CLASSPATH查找.class文件的根目录，
>> - 从根目录开始，解释器获取包的名称并将每个句点替换成斜杆或者反斜杠(这个取决于系统)，以从CLASSPATH根中产生一个路径名称
> - 得到的路径会与CLASSPATH中的各个不同的项相连接，解释器就在这些目录中查找与你所要创建的类的名称相关的.class文件。
        
<h3 id='4.2'>4.2 包访问权限</h3>  
        
#### 1) 介绍
> - 包访问权：默认没有修饰关键词，可以访问包内的类，但是对包外则为private
> - public：则包内外都能访问
> - protected： 继承的类也能访问，但是包外非继承的类则不能访问
> - private：类私有
        
<h3 id='4.3'>4.3 接口和实现</h3>  
        
#### 1) 介绍
> - 具体实现的隐藏：访问权限的控制
> - 封装：把数据和方法包装紧类中，以及具体实现的隐藏，其结果是一个同时带有特征和行为的数据类型。
> - 封装的原因：
>> - 一方面是设定客户端程序员可以使用和不可以使用的界限
>> - 另一方面是将接口和具体实现进行分离，客户端程序员除了可以想接口发送消息之外什么都不可以做，避免破坏客户端代码
#### 2) 一般做法
> - 将public成员至于开头，后面跟着protected、包访问权和private成员
        
<h3 id='4.4'>4.4 类的访问权限</h3>  
        
#### 1) 限制规则
> - 每一个编译单元都只能有一个public类，作为单一的公共接口，如果一个编译单元内有一个或者多个public类，编译器就会给出出错消息
> - 类的公共接口的名称必须跟该编译单元的文件名相匹配，包括大小写，如果不匹配也会报错；
> - 虽然不常用，但是编译单元内完全不带public也是可能的，可以随意对文件命名
        
        
------      
        
<h2 id='5'>五、复用类</h2>
<h3 id='5.1'>5.1 介绍</h3>  
        
#### 1) 四种方法
> - 组合，由现有类的对象所组成
> - 继承 
>> - 需要在构造器中调用基类构造器来初始化基类
>> - 构建过程是从基类“向外”扩散的，所有基类在导出类构造器可以访问它之前就已经完成了初始化。
>> - 编译器会为你合成一个默认的无参构造器，并自动调用
>> - 但是如果你要初始化有参的构造器，则必须借助关键字super.
> - 代理 这个用得比较少，并没有使用extends关键字，而是直接在类中实现继承类，然后继承实例的某些方法
> - 结合使用组合和继承
        
#### 2) 确保正确的清理
> -                                              析构函数是C++中的概念，指的是对象被销毁时自动被调用的函数。
#### 3) 向上转型
> - 由导出类转换为基类，在UML图上显示的是向上移动。
> - 特点：从一个较为专用的类型向通用的类型转换，所以总是安全的
> - 唯一可能发生的事情是丢失方法
> - 如果一个方法是private，他就不是接口，导出类无法覆盖该方法。即便你在导出类以相同的名称不同的修饰关键字（protected or public or 包访问权限）
#### 4) final关键字
> - 通常指“这是无法改变的”
> - 适用范围：数据、方法和类
> - 数据：一个永不改变的编译时常量，或者是运行时被初始化的值，而你不希望它被改变。所以这类常量必须是基本数据类型，而且在定义的时候，必须对其进行赋值
> - 一个既是static又是final的域只占据一段不能改变的存储空间
> - 类或者数组：final使对象引用恒定不变，一旦引用被用于初始化指向一个对象或者数组，就无法再把它改为指向另一个对象。然而，对象本身却是可以被修改的。
> - 方法：好处有两个
>> - 第一把方法锁定，以防止任何继承类修改它的含义，这是处于设计的考虑，保持不变且不会被覆盖；
>> - 第二个原因是效率，但是这种能提高效率的观点是早期提出的。当编译器发现一个final方法的时候，它会进行非常谨慎的判断。跳过执行方法调用机制（将参数压入栈，跳至方法代码处执行，然后跳回并清理栈中的参数，处理返回值）而采用插入程序代码的方式，即内嵌调用，以方法体中实际代码的副本替代方法调用，以消除方法调用的开销。但是如果你的方法很大，程序代码就会膨胀，因而有可能看不到内嵌带来的任何性能的提高。
> - 空白final：即被声明为final但是又未给定初值的域。这样的好处是可以适应不同的对象，而又保持其恒定不变的特性。
> - final和private关键字的比较：类中所有的private都隐晦地指定为final，这是因为在类外无法覆盖它，对private方法添加final修饰词，并不能给该方法增加任何额外的意义；
#### 5) 初始化及类的加载
> - 传统的语言中的顺序
>> - 程序作为启动过程一部分立刻被加载；
>> - 初始化，需要注意，如果某个static期望另一个static在被初始化之前就能有效地使用它，那么就会出现问题
>> - 程序运行
> - Java中就不会存在上述初始化的问题，因为Java中所有的事物都是对象，每个类的编译代码都存在与他自己的独立文件中，该文件只在需要使用程序代码时才会被加载，即加载发生于创建类的而第一个对象之时。“类的代码在初次使用时才加载”。初次使用之处也是static初始化发生之处。这就有效保证了类之间的依赖问题。
        
        
------      
        
<h2 id='6'>六、多态</h2>
<h3 id='6.1'>6.1 介绍</h3>  
        
#### 1) 数据在OOP中的三个特征
> - 抽象，继承和多态
> - “封装”通过合并特性和行为来创建新的数据类型
#### 2) 再论向上转型
> - 主要问题是向上转型时会忘记本身的类型是什么
                
                public void play(Instrument a) {
                    print("Instrument");
                }
> - 解决办法：方法调用绑定
>> - 绑定：将一个方法调用同一个方法主体关联起来
>> - 前期绑定：在程序执行前进行绑定，面向过程的语言不要选择就默认的绑定方式
>> - 后期绑定：程序运行时根据对象的类型进行绑定，Java中除了static方法和final方法之外，其他所有方法都是后期绑定。使用final方法除了可以防止别人覆盖，还可以有效地关闭动态绑定
> - 其实给我的感觉，后期绑定和覆盖方法有点类似
> - 有一点需要注意的是，Parent.field和Son.field并不是多态，因为编译器给他们分配了不同的存储空间。实际上Son类拥有两个field域，如果需要得到Parent.field，需要显式指明为Super.field
                
                Class Parent {
                    public int field = 0;
                }

                Class Son extends Parent{
                    public int field = 1;
                }

        
<h3 id='6.2'>6.2 构造器和多态</h3>  
        
#### 1) 构造器的调用顺序
> - 在其他任何事物发生之前，将分配给对象的存储空间初始化为二进制的零
> - 调用基类构造器，从根开始往下调用到最底层的导出类。调用时有可能会出现基类方法被导出类覆盖，但是初始值却为基类的默认值而非导出类的初始值的现象。
> - 按声明顺序调用成员的初始化方法。
> - 调用导出类构造器的主体
>>>>>> ![图6-1 构造器调用顺序的困惑.png]()
#### 2) 构造器内部的多态方法的行为
> - 如果要调用构造器内部的一个动态绑定的方法，但是这个方法有可能会被覆盖，那调用的结果就难以预测了，有可能会相当的难以预料
> - 所以编写构造器的时候有一条有效的准则：“用尽可能简单的方法使对象进入正常的状态，如果可以的化，避免调用其他方法”
> - 构造器中唯一可以被安全调用的只有基类的final方法或者private方法。
#### 3) 协变返回类型
> - 存在两组继承类组合A1，A2，B1，B2，其中A2覆盖A1中的某个方法，B1，和B2中的方法分别返回A1，和A2的方法，这样做的话A1的方法就不会被覆盖。我觉得这不是明显的吗？为什么还要搞一个这么高大上的名字。
> - 其实按照后期的理解，协变返回类型指的应该是返回值是别的类

        
<h3 id='6.3'>6.3 用继承进行设计</h3>  
        
#### 1) 一条通用的准则
> - 用继承表达行为间的差异，并用字段表达状态上的变化
> - 纯继承与拓展
>> - 纯继承是一种纯粹的“is-a”关系，导出类只覆盖基类的方法，不独自创造新的方法
>> - 拓展继承“is-like-a”,向上转型会丢失部分信息，向下转型不安全的，因为“形状变大了”。要解决向下转型的问题，必须进行转型检查。即便使用加括号形式进行类型转换，在运行时仍然会对其进行检查。称作“运行时类型识别”（RTTI）
                
                (Son)parent.sonDoSomething(); // Exception thrown

        
        
------      
        
<h2 id='7'>七、多态</h2>
<h3 id='7.1'>7.1 接口</h3>  
        
#### 1) 抽象类和抽象方法
> - 建立接口的原因：不同的子类可以用不同的方式表示此接口，通用接口建立起一种基本形式。以此表示所有导出类的共同部分
> - 建立抽象类的原因：简单的一个接口几乎是没有任何意义的，因为你无法使用和编译时去测试它。所以Java提供给一个叫做“抽象方法”的机制。这种方法是不完整的，仅有声明没有方法体
                
                abstract void f();
> - 包含抽象方法的类叫做抽象类，如果一个类包含一个或者多个抽象方法，该类必须被限定为抽象，否则编译器会报错
> - 如果从一个抽象类继承，就必须为基类中的所有对象方法提供方法定义。否则，编译器将会强制用abstract关键字来限定这个类。
> - 抽象类里面的方法可以不全是抽象的
#### 2) 接口
> - Interface这个关键字产生一个极度抽象的类，他根本没有提供任何具体的实现
> - 接口的每一个方法确实都只是一个声明，这是编译器所允许的在接口中唯一能够存在的事物。此外，接口中没有任何方法被声明是public的，但是它们自动就是public的。
> - 