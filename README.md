# Java_Study

## 作者：冰红茶  
## 参考书籍：《Java编程思想》第四版

------    


  大数据的基础是Java和Linux，以后尽管进不了大数据的领域，也希望能借助此基础进入后端领域^_ ^
     
## 目录
## [一、简介](#1)
### [1.1 对象导论](#1.1)
## [二、基础语法](#2)
### [2.1 操作符](#2.1)
### [2.2 流程控制](#2.2)
## [三、初始化与清理](#3)
### [3.1 初始化](#3.1)
### [3.2 清理](#3.2)
## [四、访问权限与控制](#4)
### [4.1 包：库单元](#4.1)
### [4.2 包访问权限](#4.2)
### [4.3 接口和实现](#4.3)
## [五、复用类](#5)
### [5.1 介绍](#5.1)
## [六、多态](#6)
### [6.1 介绍](#6.1)
### [6.2 构造器和多态](#6.2)
### [6.3 用继承进行设计](#6.3)
## [七、接口](#7)
### [7.1 接口](#7.1)
### [7.2 通过继承来拓展接口和接口中的域](#7.2)
## [八、内部类](#8)
### [8.1 介绍](#8.1)
### [8.2 为什么需要内部类](#8.2)
## [九、持有对象](#9)
### [9.1 介绍](#9.1)
## [十、通过异常处理错误](#10)
### [10.1 介绍](#10.1)
        
------      
        
<h2 id='1'>一、简介</h2>
<h3 id='1.1'>1.1 对象导论</h3>  
        
#### 1) 总体思路
> - 模版
        

------      
        
<h2 id='2'>二、基础语法</h2>
<h3 id='2.1'>2.1 操作符</h3>  
        
#### 1) 总体思路
> - 模版
        
<h3 id='2.2'>2.2 流程控制</h3>  
        
#### 1) 总体思路
> - 模版
                
        
------      
        
<h2 id='3'>三、初始化与清理</h2>
<h3 id='3.1'>3.1 初始化</h3>  
        
#### 1) 总体思路
> - 模版
        
<h3 id='3.2'>3.2 清理</h3>  
        
#### 1) 总体思路
> - 模版
        
        
------      
        
<h2 id='4'>四、访问权限与控制</h2>
<h3 id='4.1'>4.1 包：库单元</h3>  
        
#### 1) 介绍
> - 包内包含有一组类，在单一的名字空间之下被组织在一起
> - 比如：全名是java.util.ArrayList
> - 使用的时候利用import关键字
                
                import java.util.ArrayList;
                import java.util.*
> - 一个Java源文件通常被称为是编译单元，带后缀名.java。内部有且仅被允许有一个public类，否则编译器不会接受。在编译单元之中还有额外的类的话，那么在包之外的世界是无法看见这些雷达额。因为他们不是public类，而且他们只要用来为主public类提供支持。
> - package名称的第一部分是类的创建者的反顺序Internet域名

#### 2) 代码组织
> - java可运行程序是一组可以打包并压缩为一个Java文档文件(JAR，使用Java的jar文档生成器)的.class文件。Java解释器负责这些文件的查找
> - 解释器运行过程：
>> - 找出环境变量CLASSPATH，通过CLASSPATH查找.class文件的根目录，
>> - 从根目录开始，解释器获取包的名称并将每个句点替换成斜杆或者反斜杠(这个取决于系统)，以从CLASSPATH根中产生一个路径名称
> - 得到的路径会与CLASSPATH中的各个不同的项相连接，解释器就在这些目录中查找与你所要创建的类的名称相关的.class文件。
        
<h3 id='4.2'>4.2 包访问权限</h3>  
        
#### 1) 介绍
> - 包访问权：默认没有修饰关键词，可以访问包内的类，但是对包外则为private
> - public：则包内外都能访问
> - protected： 继承的类也能访问，但是包外非继承的类则不能访问
> - private：类私有
        
<h3 id='4.3'>4.3 接口和实现</h3>  
        
#### 1) 介绍
> - 具体实现的隐藏：访问权限的控制
> - 封装：把数据和方法包装紧类中，以及具体实现的隐藏，其结果是一个同时带有特征和行为的数据类型。
> - 封装的原因：
>> - 一方面是设定客户端程序员可以使用和不可以使用的界限
>> - 另一方面是将接口和具体实现进行分离，客户端程序员除了可以想接口发送消息之外什么都不可以做，避免破坏客户端代码
#### 2) 一般做法
> - 将public成员至于开头，后面跟着protected、包访问权和private成员
        
<h3 id='4.4'>4.4 类的访问权限</h3>  
        
#### 1) 限制规则
> - 每一个编译单元都只能有一个public类，作为单一的公共接口，如果一个编译单元内有一个或者多个public类，编译器就会给出出错消息
> - 类的公共接口的名称必须跟该编译单元的文件名相匹配，包括大小写，如果不匹配也会报错；
> - 虽然不常用，但是编译单元内完全不带public也是可能的，可以随意对文件命名
        
        
------      
        
<h2 id='5'>五、复用类</h2>
<h3 id='5.1'>5.1 介绍</h3>  
        
#### 1) 四种方法
> - 组合，由现有类的对象所组成
> - 继承 
>> - 需要在构造器中调用基类构造器来初始化基类
>> - 构建过程是从基类“向外”扩散的，所有基类在导出类构造器可以访问它之前就已经完成了初始化。
>> - 编译器会为你合成一个默认的无参构造器，并自动调用
>> - 但是如果你要初始化有参的构造器，则必须借助关键字super.
> - 代理 这个用得比较少，并没有使用extends关键字，而是直接在类中实现继承类，然后继承实例的某些方法
> - 结合使用组合和继承
        
#### 2) 确保正确的清理
> -                                              析构函数是C++中的概念，指的是对象被销毁时自动被调用的函数。
#### 3) 向上转型
> - 由导出类转换为基类，在UML图上显示的是向上移动。
> - 特点：从一个较为专用的类型向通用的类型转换，所以总是安全的
> - 唯一可能发生的事情是丢失方法
> - 如果一个方法是private，他就不是接口，导出类无法覆盖该方法。即便你在导出类以相同的名称不同的修饰关键字（protected or public or 包访问权限）
#### 4) final关键字
> - 通常指“这是无法改变的”
> - 适用范围：数据、方法和类
> - 数据：一个永不改变的编译时常量，或者是运行时被初始化的值，而你不希望它被改变。所以这类常量必须是基本数据类型，而且在定义的时候，必须对其进行赋值
> - 一个既是static又是final的域只占据一段不能改变的存储空间
> - 类或者数组：final使对象引用恒定不变，一旦引用被用于初始化指向一个对象或者数组，就无法再把它改为指向另一个对象。然而，对象本身却是可以被修改的。
> - 方法：好处有两个
>> - 第一把方法锁定，以防止任何继承类修改它的含义，这是处于设计的考虑，保持不变且不会被覆盖；
>> - 第二个原因是效率，但是这种能提高效率的观点是早期提出的。当编译器发现一个final方法的时候，它会进行非常谨慎的判断。跳过执行方法调用机制（将参数压入栈，跳至方法代码处执行，然后跳回并清理栈中的参数，处理返回值）而采用插入程序代码的方式，即内嵌调用，以方法体中实际代码的副本替代方法调用，以消除方法调用的开销。但是如果你的方法很大，程序代码就会膨胀，因而有可能看不到内嵌带来的任何性能的提高。
> - 空白final：即被声明为final但是又未给定初值的域。这样的好处是可以适应不同的对象，而又保持其恒定不变的特性。
> - final和private关键字的比较：类中所有的private都隐晦地指定为final，这是因为在类外无法覆盖它，对private方法添加final修饰词，并不能给该方法增加任何额外的意义；
#### 5) 初始化及类的加载
> - 传统的语言中的顺序
>> - 程序作为启动过程一部分立刻被加载；
>> - 初始化，需要注意，如果某个static期望另一个static在被初始化之前就能有效地使用它，那么就会出现问题
>> - 程序运行
> - Java中就不会存在上述初始化的问题，因为Java中所有的事物都是对象，每个类的编译代码都存在与他自己的独立文件中，该文件只在需要使用程序代码时才会被加载，即加载发生于创建类的而第一个对象之时。“类的代码在初次使用时才加载”。初次使用之处也是static初始化发生之处。这就有效保证了类之间的依赖问题。
        
        
------      
        
<h2 id='6'>六、多态</h2>
<h3 id='6.1'>6.1 介绍</h3>  
        
#### 1) 数据在OOP中的三个特征
> - 抽象，继承和多态
> - “封装”通过合并特性和行为来创建新的数据类型
#### 2) 再论向上转型
> - 主要问题是向上转型时会忘记本身的类型是什么
                
                public void play(Instrument a) {
                    print("Instrument");
                }
> - 解决办法：方法调用绑定
>> - 绑定：将一个方法调用同一个方法主体关联起来
>> - 前期绑定：在程序执行前进行绑定，面向过程的语言不要选择就默认的绑定方式
>> - 后期绑定：程序运行时根据对象的类型进行绑定，Java中除了static方法和final方法之外，其他所有方法都是后期绑定。使用final方法除了可以防止别人覆盖，还可以有效地关闭动态绑定
> - 其实给我的感觉，后期绑定和覆盖方法有点类似
> - 有一点需要注意的是，Parent.field和Son.field并不是多态，因为编译器给他们分配了不同的存储空间。实际上Son类拥有两个field域，如果需要得到Parent.field，需要显式指明为Super.field
                
                Class Parent {
                    public int field = 0;
                }

                Class Son extends Parent{
                    public int field = 1;
                }

        
<h3 id='6.2'>6.2 构造器和多态</h3>  
        
#### 1) 构造器的调用顺序
> - 在其他任何事物发生之前，将分配给对象的存储空间初始化为二进制的零
> - 调用基类构造器，从根开始往下调用到最底层的导出类。调用时有可能会出现基类方法被导出类覆盖，但是初始值却为基类的默认值而非导出类的初始值的现象。
> - 按声明顺序调用成员的初始化方法。
> - 调用导出类构造器的主体
>>>>>> ![图6-1 构造器调用顺序的困惑.png](https://github.com/hblvsjtu/Java_Study/blob/master/picture/%E5%9B%BE6-1%20%E6%9E%84%E9%80%A0%E5%99%A8%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%E7%9A%84%E5%9B%B0%E6%83%91.png?raw=true)
#### 2) 构造器内部的多态方法的行为
> - 如果要调用构造器内部的一个动态绑定的方法，但是这个方法有可能会被覆盖，那调用的结果就难以预测了，有可能会相当的难以预料
> - 所以编写构造器的时候有一条有效的准则：“用尽可能简单的方法使对象进入正常的状态，如果可以的化，避免调用其他方法”
> - 构造器中唯一可以被安全调用的只有基类的final方法或者private方法。
#### 3) 协变返回类型
> - 存在两组继承类组合A1，A2，B1，B2，其中A2覆盖A1中的某个方法，B1，和B2中的方法分别返回A1，和A2的方法，这样做的话A1的方法就不会被覆盖。我觉得这不是明显的吗？为什么还要搞一个这么高大上的名字。
> - 其实按照后期的理解，协变返回类型指的应该是返回值是别的类

        
<h3 id='6.3'>6.3 用继承进行设计</h3>  
        
#### 1) 一条通用的准则
> - 用继承表达行为间的差异，并用字段表达状态上的变化
> - 纯继承与拓展
>> - 纯继承是一种纯粹的“is-a”关系，导出类只覆盖基类的方法，不独自创造新的方法
>> - 拓展继承“is-like-a”,向上转型会丢失部分信息，向下转型不安全的，因为“形状变大了”。要解决向下转型的问题，必须进行转型检查。即便使用加括号形式进行类型转换，在运行时仍然会对其进行检查。称作“运行时类型识别”（RTTI）
                
                (Son)parent.sonDoSomething(); // Exception thrown

        
        
------      
        
<h2 id='7'>七、多态</h2>
<h3 id='7.1'>7.1 接口</h3>  
        
#### 1) 抽象类和抽象方法
> - 建立接口的原因：不同的子类可以用不同的方式表示此接口，通用接口建立起一种基本形式。以此表示所有导出类的共同部分
> - 建立抽象类的原因：简单的一个接口几乎是没有任何意义的，因为你无法使用和编译时去测试它。所以Java提供给一个叫做“抽象方法”的机制。这种方法是不完整的，仅有声明没有方法体
                
                abstract void f();
> - 包含抽象方法的类叫做抽象类，如果一个类包含一个或者多个抽象方法，该类必须被限定为抽象，否则编译器会报错
> - 如果从一个抽象类继承，就必须为基类中的所有对象方法提供方法定义。否则，编译器将会强制用abstract关键字来限定这个类。
> - 抽象类里面的方法可以不全是抽象的
#### 2) 接口
> - Interface是一种更加纯粹的抽象类。
> - Interface这个关键字产生一个极度抽象的类，他根本没有提供任何具体的实现
> - 接口的每一个方法确实都只是一个声明，这是编译器所允许的在接口中唯一能够存在的事物。此外，接口中没有任何方法被声明是public的，但是它们自动就是public的。
#### 3) 完全解耦
> - 策略设计模式：能够根据所传递的参数对象的不同而具有不同行为的方法。这类方法包含所要执行算法中固定不变的部分，而“策略”就是传递进去的参数对象。
>>>>>> ![图7-1 策略设计模式.png](https://github.com/hblvsjtu/Java_Study/blob/master/picture/%E5%9B%BE7-1%20%E7%AD%96%E7%95%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png?raw=true)
> - 适配器模式：其实是使用了代理
> - 工厂模式
>>>>>> ![图7-3 工厂模式1](https://github.com/hblvsjtu/Java_Study/blob/master/picture/%E5%9B%BE7-3%20%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F1.png?raw=true)
>>>>>> ![图7-3 工厂模式2](https://github.com/hblvsjtu/Java_Study/blob/master/picture/%E5%9B%BE7-3%20%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F2.png?raw=true)
#### 4) Java中的多重继承
> - 接口是一种更加纯粹的抽象类，因为接口根本没有任何具体的实现，没有任何与接口相关的存储，也就无法阻止多个接口的组合；
                
                class Hero extends ActionCharacter implements implementsA, implementsB, implementsC
>>>>>> ![图7-2 Java中的多重继承](https://github.com/hblvsjtu/Java_Study/blob/master/picture/%E5%9B%BE7-2%20Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF.png?raw=true)
#### 5) 面向接口编程
> - 原因：
>> - 为了能够向上转型为多个基类型
>> - 防止客户端程序员创建该类的对象，并确保这仅仅是一个接口
        
<h3 id='7.2'>7.2 通过继承来拓展接口和接口中的域</h3>  
        
#### 1) 方法
> - 直接正在接口后面跟extends关键字，多个继承使用逗号作为分割；
> - 注意避免多个接口中方法名字的冲突
#### 2) 接口中的域
> - 放入接口中的任何域都是自动static和final的
> - 所以接口就成为一种很便捷的用来创建常量组的工具
> - 而且不需要添加private或者final或者static关键字
> - 不能是“空final”，但是可以接受被非常量表达式初始化
> - 嵌套在另一个接口中的接口自动就是public的
        
        
------      
        
<h2 id='8'>八、内部类</h2>
<h3 id='8.1'>8.1 介绍</h3>  
        
#### 1) 内部类是什么
> - 将一个类的定义放在另一个类的定义内部，类似于一种代码隐藏机制
> - 允许把一些逻辑相关的类组织在一起，并控制位于内部的类的可视性
> - 内部类和组合是完全不同的概念
> - 如果要在外部使用非静态方法创建某个内部类对象，则需要具体指明这个对象的类型：OuterClassName.InnerClassName
> - 普通的内部类不能有static数据和static字段，也不能包含嵌套类。这是因为内部类不是static的话，里面的方法和字段是static又有什么用。
> - 创建内部成员类的时候，需要使用“外围类”  + “.” + “new”语法
#### 2) 链接到外部类
> - 可以访问外围对象（其实就是它的上一层嵌套对象）的所有成员（该成员跟内部类处于同一级别），而不需要任何特殊条件
> - 还拥有其外围类的所有元素的访问权一个指向那个外围对象的引用。然后，当你访问这个外围类下对象的时候就是用那个引用来选择外围类的成员
> - 原因是什么：当一个外围类对象创建一个内部对象的时候，此内部独享必定会秘密捕获
> - 通过一个外部类名字 + ‘.’ + this可以链接到外围类对象
                
                如： Outer.this // 表示外围类的引用，如果单独是一个this的话则表示内部类
#### 3) 内部类和向上转型
> - 使用内部类来隐藏使用的接口，关键是使用协同返回
> - 内部类前添加private，那么除了外围类没有其他可以访问；如果内部类前添加protected，那么是由外围类及其子类，还有与外围类同一个包中的类能够访问
>>>>>> ![图7-4 内部类隐藏接口](https://github.com/hblvsjtu/Java_Study/blob/master/picture/%E5%9B%BE7-4%20%E5%86%85%E9%83%A8%E7%B1%BB%E9%9A%90%E8%97%8F%E6%8E%A5%E5%8F%A3.png?raw=true)
#### 4) 在方法和作用域内的内部类
> - 在方法作用域内创建一个完整的类，这被称作局部内部类
> - 在方法之外无法访问，如果需要return该局部内部类，那么需要把该局部内部类进行继承和实现某接口，然后在使用的时候进行向上转型
#### 5) 匿名内部类
> - 方法的返回值的生成与表示这个返回值的类的定义结合在一起，其实匿名的是一个已有接口的实现
> - 化简前
>>>>>> ![图7-5 匿名内部类化简前](https://github.com/hblvsjtu/Java_Study/blob/master/picture/%E5%9B%BE7-5%20%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%8C%96%E7%AE%80%E5%89%8D.png?raw=true)
> - 化简后
>>>>>> ![图7-6 匿名内部类化简后](https://github.com/hblvsjtu/Java_Study/blob/master/picture/%E5%9B%BE7-6%20%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%8C%96%E7%AE%80%E5%90%8E.png?raw=true)
> - 需要注意的是，在匿名内部类内使用的参数必须是在方法定义的时候必须是final的
                
                public class Parcel10 {
                    destination(final String dest, final float price) {
                        return new Destination() {
                            System.out.printIn(dest * price);
                        }
                    }
                }
#### 6) 嵌套类
> - 如果不需要内部对象与其外围对象之间有联系，那么可以将内部类声明为static
> - 不能从嵌套类对象中访问非静态的外围类对象
> - 内部类可以通过一个特殊的this链接到外围类对象，但是嵌套类就没有这个特殊的this引用，使得它的使用跟静态方法类似。
> - 一个内部类被嵌套多少层都并不重要，他都能透明的访问所有它所潜入的外围类的所有成员
#### 7) 内部类的继承
> - 继承自内部类的时候需要使用特殊的语法进行初始化，否则编译会不通过
                
                enclosingClassReference.super();
#### 8) 内部类的标识符
> - 由于每个类都会产生.class文件
> - 内部类都有自己的.class文件，只是该文件的名字是：外围类名字 + “$” + 内部类名字
        
<h3 id='8.2'>8.2 为什么需要内部类</h3>  
        
#### 1) 原因
> - 每个内部类都能独立继承一个接口的实现，所以五路外围类是否已经继承了某个接口的实现，对内部类都没有影响
> - 内部类使得多重继承的解决方案变得完整
#### 2) 闭包和回调
        
        
------      
        
<h2 id='9'>九、持有对象</h2>
<h3 id='9.1'>9.1 持有对象</h3>  
        

>>>>>> ![图7-10 容器的分类图](https://github.com/hblvsjtu/Java_Study/blob/master/picture/%E5%9B%BE7-10%20%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB%E5%9B%BE.png?raw=true)
        
#### 1) 泛型
> - 应用于容器后，表示该容器可容纳的子元素类型，并用尖括号括起来
                
                ArrayList<Apple> apples = new ArrayList<Apple>();
> - 如果没有在该使用泛型的地方使用泛型，就会出现警告信息，提示没有使用泛型。在这里可以使用Java SE5所特有的注解来抑制警告信息。注解以“@”符号开头，可以接受参数，这里的@SuppressWarnings注解极其参数表示只有有关“不受检查的异常”的警告信息应该被抑制
> - 尖括号括起来的**类型参数**指定了这个容器实例可以保存的类型（可以有多个）。
> - 通过使用泛型就可以在编译期防止将错误类型的对象放置在容器中。
#### 2) 保存对象
> - Collection 一个独立元素的序列，这些元素都服从一条或者多条规则
>> - List 按照插入的顺序保存元素
>> - Set 不能有重复的元素
>> - Queue 按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）
> - Map 一组成对的“键值对”对象，允许使用键来查找值。这种关联关系称为“字典”
#### 3) 添加一组元素
> - 普通的增加元素只需要collection.add()即可
> - map的话用put()方法
> - 所有的Collectons类型都包含该方法：addAll()，接受一个Collection对象，以及一个数组或者是一个用逗号分隔的列表，将元素添加到Collections中。该方法只接受另一个Collection对象作为参数
                
                Collection<Integer> collection = new ArrayList<Integer>(Arrays.asList(1,2,3,4,5));
                //实例的方法 因为不包含对象作为参数，所以运行起来比对象的方法要快
                collection.addAll(Arrays.asList({6, 7, 8, 9})); 
                Collections.addAll(collection, 11, 12, 13, 14, 15); // 对象的方法
> - Arrays.asList()方法接受一个数组或是一个用逗号分隔的元素列表（使用可变参数），并转换为一个List对象。
                
                List<Integer> list = Arrays.asList(16, 17, 18, 19, 20);
#### 4) List
> - List承诺可以将元素维护在特定的序列中。List接口在Collection的基础上添加了大量的方法，使得可以在List的中间插入和移除元素
> - 两种基本类型的List
>> - ArrayList，擅长于随机访问元素，但是在List中间插入和移除元素时比较慢
>> - LinkedList，它通过代价较低的在List中间进行的插入和删除操作，提供了优化的顺序访问。但是在随机访问方面相对比较慢
#### 5) 迭代器
> - 迭代器是一个对象，也是一种设计模式。它的工作是遍历并选择序列中的对象。而客户端程序员不必要知道该序列底层的结构。
> - Java的Iterator只能单向移动
> - 迭代器其实也是一个容器，也需要在后面添加泛型
                
                Iterator<Pet> it = pets.iterator
> - 可以说，迭代器统一了对容器的访问方式
> - 方法
>> - 使用方法iterator()要求容器返回一个Iterator，Iterator将准备好返回序列的第一个元素。
>> - 使用next()获得序列中的下一个元素
>> - 使用hasNext()检查序列中是否还有元素
>> - 使用remove()将迭代器新近返回的元素删除
> - ListIterator是一个更加强大的Iterator的子类型
>> - 除了可以向前移动，还可以双向移动。
>> - 还可以产生相对于迭代器在列表中指向当前位置的前一个和后一个的索引
>> - 并且可以使用set()方法替换它访问过的最后一个元素
>> - 可以通过调用listIterator()要求容器返回一个指向List开始处的ListIterator
>> - 也可以通过调用listIterator(n)要求容器返回一个指向List列表索引为n的ListIterator
>> - 但是只能用于各种List类的访问。
>>>>>> ![图7-7 iterator迭代器](https://github.com/hblvsjtu/Java_Study/blob/master/picture/%E5%9B%BE7-7%20iterator%E8%BF%AD%E4%BB%A3%E5%99%A8.png?raw=true)
#### 6) LinkedList
> - LinkedList也像ArrayList那样基本实现了List接口
> - 在执行某些操作（在List的中间插入和移除）时比ArrayList更高效
> - 能够实现栈的所有功能的方法
> - 基本方法
>> - removeFirst()
>> - removeLast()
>> - getFirst()
>> - addFirst()
>> - addLast()
>> - peek() // 移除并返回第一个元素
>> - pop() // 移除第一个元素并返回列表的头
>> - poll()
#### 7) Stack
> - 先进后出，用LinkedList来实现
> - 因为LinkedList能够实现栈的所有功能的方法
> - > - 其实是存在java.util.Stack这个公共类，但是因为使用LinkedList可以产生更好的Stack，因此一般都是自己创建
>>>>>> ![图7-8 使用LinkedList实现stack](https://github.com/hblvsjtu/Java_Study/blob/master/picture/%E5%9B%BE7-8%20%E4%BD%BF%E7%94%A8LinkedList%E5%AE%9E%E7%8E%B0stack.png?raw=true)
#### 8) Set
> - 不保存重复的元素
> - 具有与Collection完全一样的接口，因此没有额外的功能，其实Set就是Collection，只是行为不同（继承和多态的典型应用）
> - 最常被使用的是测试归属性，也就是说容易询问某个对象是否在某个Set中
> - 实现这个接口的常用类有HashSet,TreeSet或者是LinkedHashSet
> - 排列的顺序没有任何规律可循，这是因为处于速度的考虑，而且不同大的实现类的元素存储方式不同
>> - HashSet使用了散列函数
>> - TreeSet使用了红黑树，保持元素的排序状态
>> - LinkedHashList也是使用了散列，但是 看起来像是使用了链表来维护元素的插入顺序。
> - 一般使用contains()测试Set的归属性
#### 9) Map
> - Map<Person, List<Pet>>
> - 实现类: HashMap, treeMap
> - HashMap用于快速访问，treeMap
> - containsKey()和containsValue()来测试Map
> - treeMap
> - put()
> - get()
>>>>>> ![图7-9 map的使用](https://github.com/hblvsjtu/Java_Study/blob/master/picture/%E5%9B%BE7-9%20map%E7%9A%84%E4%BD%BF%E7%94%A8.png?raw=true)
#### 10) Queue
> - 队列
> - offer()方法在允许的情况下，将一个元素插入队尾，或者返回false。
> - peek()和element()都将在不溢出的情况下返回队头，当队列为空的时候，peek()返回null，但是element()则抛出NoSuchElementException异常
> - poll()和remove()方法将一处并返回队头，当队列为空的时候， poll()返回null，但是remove()则抛出NoSuchElementException异常
> - LinkedList提供了方法支持队列的行为，并且它实现了Queue接口
> - PriorityQueue优先级队列，声明下一个弹出的元素是最需要的元素
#### 11) Foreach
> - 主要用于数组，但是也可以用于Collection对象
                
                for(String s: cs) {
                    // doSomething
                }


        
        
------      
        
<h2 id='10'>十、通过异常处理错误</h2>
<h3 id='10.1'>10.1 概念</h3>  
        
#### 1) 基本理念
> - “结构不佳的代码不能运行”
> - 对于异常处理的实现最早可以追溯到20世纪60年代的操作系统，设甚至于BASIC语言中的on error goto语句
> - C++的异常处理机制是基于Ada，Java中的异常处理则建立在C++的基础之上
> - 一个明显的好处是，往往可以降低错误处理代码的复杂度，如果不适用异常，那就必须检查特定的错误，并在程序中的许多地方去处理它。而如果使用异常，则就不必在方法调用处进行检查。因为异常机制将把凭证能够捕获这个错误。。并且，只需要在一个地方处理错误————即所谓的异常处理程序中。
#### 2) 基本异常
> - 